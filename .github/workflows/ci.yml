# .github/workflows/ci.yml
name: Lunaris Codex CI

on:
  push:
    branches: [ main ]
    paths:
      - 'model.py'
      - 'prepare_data.py'
      - 'train.py'
      - 'inference.py'
      - 'text_cleaner/**'
      - 'data_analyzer/**'
      - 'bpe_trainer/**'
      - 'tests/**'
      - 'Makefile'
      - 'requirements.txt'
      - '.github/workflows/**'
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches: [ main ]
    paths:
      - 'model.py'
      - 'prepare_data.py'
      - 'train.py'
      - 'inference.py'
      - 'text_cleaner/**'
      - 'data_analyzer/**'
      - 'bpe_trainer/**'
      - 'tests/**'
      - 'Makefile'
      - 'requirements.txt'
      - '.github/workflows/**'

env:
  CXXFLAGS_MODE: RELEASE
  PYTHON_VERSION: '3.11'
  PYTHONUTF8: "1"

jobs:
  detect_changes:
    name: Detect Changes & Setup Matrix
    runs-on: ubuntu-latest
    outputs:
      cpp_changes: ${{ steps.cpp_changes.outputs.any_changed }}
      python_changes: ${{ steps.python_changes.outputs.any_changed }}
      should_run_cpp: ${{ steps.decision.outputs.should_run_cpp }}
      should_run_python: ${{ steps.decision.outputs.should_run_python }}
      test_matrix: ${{ steps.matrix.outputs.matrix }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect C++ Changes
        id: cpp_changes
        uses: tj-actions/changed-files@v46
        with:
          files: |
            Makefile
            text_cleaner/**
            data_analyzer/**
            bpe_trainer/**
            .github/workflows/**

      - name: Detect Python Changes
        id: python_changes
        uses: tj-actions/changed-files@v46
        with:
          files: |
            model.py
            prepare_data.py
            train.py
            inference.py
            tests/**
            requirements.txt
            .github/workflows/**

      - name: Determine Job Execution
        id: decision
        run: |
          run_cpp_flag=false
          run_python_flag=false
          if [[ "${{ steps.cpp_changes.outputs.any_changed }}" == "true" ]]; then run_cpp_flag=true; fi
          if [[ "${{ steps.python_changes.outputs.any_changed }}" == "true" ]]; then run_python_flag=true; fi
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
              echo "Forcing all relevant tests on push to main or manual dispatch."
              run_cpp_flag=true
              run_python_flag=true
          fi
          echo "should_run_cpp=$run_cpp_flag" >> $GITHUB_OUTPUT
          echo "should_run_python=$run_python_flag" >> $GITHUB_OUTPUT
          echo "CPP jobs will run: $run_cpp_flag"; echo "Python jobs will run: $run_python_flag"

      - name: Setup Test Matrix
        id: matrix
        run: |
          cat <<EOF > matrix.json
          {"os": [{"name": "ubuntu-latest", "display": "Ubuntu Latest (24.04)", "runner": "ubuntu-latest"}, {"name": "ubuntu-22.04", "display": "Ubuntu 22.04 LTS", "runner": "ubuntu-22.04"}]}
EOF # GARANTA QUE ESTE EOF EST√Å NO IN√çCIO DA LINHA
          echo "matrix=$(cat matrix.json | jq -c .)" >> $GITHUB_OUTPUT

  cpp_utilities:
    name: C++ Build & Test (${{ matrix.os.display }})
    runs-on: ${{ matrix.os.runner }}
    needs: detect_changes
    if: needs.detect_changes.outputs.should_run_cpp == 'true'
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect_changes.outputs.test_matrix) }}
    defaults: { run: { shell: bash } }
    outputs: # Nomes das sa√≠das do JOB
      text_cleaner_output_for_job: ${{ steps.executables.outputs.text_cleaner_exec }}
      data_analyzer_output_for_job: ${{ steps.executables.outputs.data_analyzer_exec }}
      bpe_processor_output_for_job: ${{ steps.executables.outputs.bpe_processor_exec }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      - name: Install Build Dependencies (Ubuntu)
        run: |
          sudo apt-get update -y && sudo apt-get install -y nlohmann-json3-dev build-essential
          g++ --version
      - name: Cache C++ Executables
        id: cache_executables
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/text_cleaner/lunaris_text_cleaner
            ${{ github.workspace }}/data_analyzer/lunaris_data_analyzer
            ${{ github.workspace }}/bpe_trainer/bpe_processor
          key: ${{ matrix.os.runner }}-cpp-exec-v2-${{ hashFiles('Makefile', 'text_cleaner/**/*.cpp', 'text_cleaner/**/*.hpp', 'data_analyzer/**/*.cpp', 'data_analyzer/**/*.hpp', 'bpe_trainer/**/*.cpp', 'bpe_trainer/**/*.hpp', '.github/workflows/**.yml') }}
          restore-keys: |
            ${{ matrix.os.runner }}-cpp-exec-v2-
      - name: Clean Previous Build Artifacts (if no cache hit)
        if: steps.cache_executables.outputs.cache-hit != 'true'
        run: |
          echo "üßπ Cleaning previous build artifacts (cache miss)..."
          make clean || echo "‚ÑπÔ∏è Clean failed or no artifacts to clean."
      - name: Build C++ Utilities (if no cache hit)
        if: steps.cache_executables.outputs.cache-hit != 'true'
        run: |
          echo "üî® Building C++ utilities (cache miss)..."
          make all CXXFLAGS_MODE=${{ env.CXXFLAGS_MODE }} && echo "‚úÖ C++ utilities built successfully."
      - name: List files after potential build/cache restore
        run: |
          echo "üìÇ LS workspace:"; ls -lA ${{ github.workspace }}/
          echo "üìÇ LS text_cleaner:"; ls -lA ${{ github.workspace }}/text_cleaner/ || true
      - name: Set and Verify Executable Paths
        id: executables # Este ID define as sa√≠das da ETAPA
        run: |
          TC_EXEC="${{ github.workspace }}/text_cleaner/lunaris_text_cleaner"
          DA_EXEC="${{ github.workspace }}/data_analyzer/lunaris_data_analyzer"
          BPE_EXEC="${{ github.workspace }}/bpe_trainer/bpe_processor"

          # Sa√≠das da ETAPA (acessadas por steps.<id>.outputs.<nome>)
          echo "text_cleaner_exec=$TC_EXEC" >> $GITHUB_OUTPUT
          echo "data_analyzer_exec=$DA_EXEC" >> $GITHUB_OUTPUT
          echo "bpe_processor_exec=$BPE_EXEC" >> $GITHUB_OUTPUT

          if [[ "${{ steps.cache_executables.outputs.cache-hit }}" == "true" ]]; then echo "‚ôªÔ∏è Cache hit reported."; else echo "üÜï No cache hit."; fi
          all_execs_found=true
          for exec_file in "$TC_EXEC" "$DA_EXEC" "$BPE_EXEC"; do
            if [ ! -f "$exec_file" ]; then echo "‚ùå ERROR: Executable not found: $exec_file"; all_execs_found=false;
            elif [ ! -x "$exec_file" ]; then echo "‚ùå ERROR: File found but not executable: $exec_file"; ls -l "$exec_file"; all_execs_found=false;
            else echo "‚úÖ Found executable: $exec_file"; ls -l "$exec_file"; fi
          done
          if [[ "$all_execs_found" != "true" ]]; then echo "üî• Executable verification failed."; exit 1; fi
          echo "All executables verified."

      - name: Run Text Cleaner Tests
        run: |
          # Usa a sa√≠da da ETAPA 'executables'
          TEXT_CLEANER_EXEC="${{ steps.executables.outputs.text_cleaner_exec }}"
          
          mkdir -p ./temp_text_cleaner_input ./temp_text_cleaner_output
          cat <<EOF > ./temp_text_cleaner_input/sample.txt
          <!DOCTYPE html><html><head><title>Test</title></head><body><!-- This is a comment --><p>Hello   World!  </p><script>alert("script content");</script>Another line.URL: http://example.com and email: test@example.com Duplicate Line Duplicate Line</body></html>
EOF # <-- ESTE DEVE ESTAR NO IN√çCIO DA LINHA, SEM ESPA√áOS ANTES

          "$TEXT_CLEANER_EXEC" --input ./temp_text_cleaner_input/sample.txt --output ./temp_text_cleaner_output/cleaned.txt --remove-html --normalize-whitespace --remove-empty-lines --to-lowercase --process-urls --url-placeholder "[url]" --process-emails --email-placeholder "[email]" --remove-exact-duplicates
          
          # Usando <<-EOF para permitir indenta√ß√£o do delimitador e do conte√∫do
          cat <<-EXPECTED_EOF > expected_output.txt
          	test
          	hello world!
          	another line.
          	url: [url] and email: [email]
          	duplicate line
EXPECTED_EOF # <-- Este pode ser indentado por causa do <<-

          if diff -u expected_output.txt ./temp_text_cleaner_output/cleaned.txt; then echo "‚úÖ Text Cleaner test passed"; else echo "‚ùå Text Cleaner test failed"; cat expected_output.txt; cat ./temp_text_cleaner_output/cleaned.txt; exit 1; fi

      - name: Run BPE Processor Tests
        run: |
          # Usa a sa√≠da da ETAPA 'executables'
          BPE_EXEC="${{ steps.executables.outputs.bpe_processor_exec }}"
          
          mkdir -p ./temp_bpe/corpus ./temp_bpe/model_output
          cat <<EOF > ./temp_bpe/corpus/corpus.txt
          hello world this is a test a test
          another line for another test of the bpe
          hello world again
EOF # <-- ESTE DEVE ESTAR NO IN√çCIO DA LINHA, SEM ESPA√áOS ANTES

          "$BPE_EXEC" --action train --corpus ./temp_bpe/corpus/corpus.txt --vocab-size 270 --output ./temp_bpe/model_output/bpe_model/ --mode byte --verbose
          REQUIRED_FILES=("./temp_bpe/model_output/bpe_model/bpe_model_lunaris.json" "./temp_bpe/model_output/bpe_model/merges_lunaris.txt" "./temp_bpe/model_output/bpe_model/vocabulary_lunaris.txt")
          for file in "${REQUIRED_FILES[@]}"; do if [ ! -f "$file" ]; then echo "‚ùå ERROR: Required BPE file not found: $file"; ls -R ./temp_bpe/model_output/; exit 1; fi; done
          TOKEN_OUTPUT=$("$BPE_EXEC" --action tokenize --model_path "./temp_bpe/model_output/bpe_model/" --input_text "hello test world" --verbose)
          if [ $? -ne 0 ] || [ -z "$TOKEN_OUTPUT" ]; then echo "‚ùå ERROR: BPE tokenization failed. Output: $TOKEN_OUTPUT"; exit 1; fi
          echo "‚úÖ BPE Processor test passed"

      - name: Cleanup Test Files
        if: always()
        run: rm -rf ./temp_text_cleaner_input ./temp_text_cleaner_output ./expected_output.txt ./temp_bpe
  
  # --- python_suite e ci_status (sem mudan√ßas significativas em rela√ß√£o √† √∫ltima vers√£o, exceto consist√™ncia de outputs se necess√°rio) ---
  python_suite:
    name: Python Tests (${{ matrix.os.display }})
    runs-on: ${{ matrix.os.runner }}
    needs: detect_changes
    if: needs.detect_changes.outputs.should_run_python == 'true'
    strategy: { fail-fast: false, matrix: "${{ fromJson(needs.detect_changes.outputs.test_matrix) }}" }
    defaults: { run: { shell: bash } }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: "${{ env.PYTHON_VERSION }}" }
      - name: Display Python Info
        run: |
          python --version; pip --version
      - name: Cache Python Dependencies
        id: cache_pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ matrix.os.runner }}-pip-v1-${{ hashFiles('requirements.txt', '.github/workflows/**.yml') }}
          restore-keys: |
            ${{ matrix.os.runner }}-pip-v1-
      - name: Install Python Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run Unit Tests
        run: python -m pytest tests/ -k "test_model" --cov=model --cov-report=xml:coverage-${{ matrix.os.name }}.xml --cov-report=term-missing --tb=short
      - name: Upload Coverage Report
        if: success() && matrix.os.name == 'ubuntu-latest' 
        uses: codecov/codecov-action@v4
        with: { token: "${{ secrets.CODECOV_TOKEN }}", files: "./coverage-${{ matrix.os.name }}.xml", flags: "model-tests-${{ matrix.os.name }}", name: "codecov-ubuntu-latest", fail_ci_if_error: true }
      - name: Create Test Datasets
        run: |
          mkdir -p ./temp_train_data ./temp_val_data
          echo "def f1(): return 't1'" > ./temp_train_data/train1.py
          echo "class C1: v='t2'" > ./temp_train_data/train2.py
          echo "def fv(): return 'vd'" > ./temp_val_data/val1.py
      - name: Test Data Preparation
        env: { HF_TOKEN: "${{ secrets.HF_TOKEN }}" }
        run: |
          python prepare_data.py --data_source_type text_file_lines --dataset_name_or_path "./temp_train_data/*.py" --tokenizer_name_or_path gpt2 --output_path ./p_data/train.bin --max_length 32 --max_examples 2 --overwrite_output
          python prepare_data.py --data_source_type text_file_lines --dataset_name_or_path "./temp_val_data/*.py" --tokenizer_name_or_path gpt2 --output_path ./p_data/val.bin --max_length 32 --max_examples 2 --overwrite_output
      - name: Test Training Pipeline
        env: { HF_TOKEN: "${{ secrets.HF_TOKEN }}" } # Renomeei memmap para bin para consist√™ncia se preferir
        run: python train.py --memmap_file_train ./p_data/train.bin --num_sequences_train 2 --memmap_file_val ./p_data/val.bin --num_sequences_val 2 --tokenizer_name_or_path gpt2 --dataset_max_length 32 --dataset_dtype int32 --model_max_seq_len 32 --d_model 32 --n_layers 1 --n_heads 1 --batch_size 1 --num_epochs 1 --device cpu --checkpoint_dir ./ckpts --log_interval 1 --save_strategy epoch --lora_rank 0 --seed 42
      - name: Test Inference Pipeline
        run: |
          CHKPT="./ckpts/best_model.pt"
          if [ ! -f "$CHKPT" ]; then ls -la ./ckpts/; exit 1; fi
          OUT=$(python inference.py --checkpoint_path "$CHKPT" --tokenizer_name_or_path gpt2 --prompt "Test:" --max_new_tokens 5 --temperature 0.5 --device cpu --no_color)
          if [ $? -ne 0 ] || [ -z "$OUT" ]; then echo "‚ùå Inference failed"; exit 1; fi; echo "Output: ${OUT:0:100}..."
      - name: Cleanup Python Test Files
        if: always()
        run: rm -rf ./temp_train_data ./temp_val_data ./p_data ./ckpts ./coverage-${{ matrix.os.name }}.xml

  ci_status:
    name: CI Status Report
    runs-on: ubuntu-latest
    needs: [detect_changes, cpp_utilities, python_suite]
    if: always()
    steps:
      - name: Determine Overall Status
        id: status
        shell: bash
        run: |
          CPP_NEEDS="${{ needs.detect_changes.outputs.should_run_cpp }}"
          PY_NEEDS="${{ needs.detect_changes.outputs.should_run_python }}"
          CPP_RES="skipped"; if [[ "$CPP_NEEDS" == "true" ]]; then CPP_RES="${{ needs.cpp_utilities.result || 'failure' }}"; fi
          PY_RES="skipped"; if [[ "$PY_NEEDS" == "true" ]]; then PY_RES="${{ needs.python_suite.result || 'failure' }}"; fi
          echo "CPP: $CPP_RES (Needs: $CPP_NEEDS), Python: $PY_RES (Needs: $PY_NEEDS)"
          SUCCESS="true"
          if [[ "$CPP_NEEDS" == "true" && "$CPP_RES" != "success" && "$CPP_RES" != "skipped" ]]; then SUCCESS="false"; fi
          if [[ "$PY_NEEDS" == "true" && "$PY_RES" != "success" && "$PY_RES" != "skipped" ]]; then SUCCESS="false"; fi
          if [[ "$CPP_NEEDS" == "false" && "$PY_NEEDS" == "false" ]]; then SUCCESS="true"; fi # Se nada precisava rodar, √© sucesso
          echo "overall_success=$SUCCESS" >> $GITHUB_OUTPUT; if $SUCCESS; then echo "‚úÖ CI SUCCESS"; else echo "‚ùå CI FAILURE"; fi
      - name: Post Comment (PR)
        if: github.event_name == 'pull_request'
        env: { GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}", GH_REPO: "${{ github.repository }}" }
        run: |
          ICON="‚úÖ"; TEXT="SUCCESS"; if [[ "${{ steps.status.outputs.overall_success }}" == "false" ]]; then ICON="‚ùå"; TEXT="FAILED"; fi
          BODY="---**Lunaris Codex CI (Ubuntu Only): $TEXT $ICON**\nWorkflow: \`${{ github.workflow }}\`\nBranch: \`${{ github.head_ref }}\` (Commit: \`${{ github.sha }}\`)\nüîó [View Details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n*Automated message.*"
          gh pr comment ${{ github.event.pull_request.number }} --body "$BODY" || echo "‚ö†Ô∏è Comment failed."
      - name: Final Status Check
        shell: bash
        run: |
          if [[ "${{ steps.status.outputs.overall_success }}" == "false" ]]; then echo "‚ùå CI FAILED"; exit 1; else echo "‚úÖ CI PASSED"; fi
