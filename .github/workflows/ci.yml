# .github/workflows/ci.yml
name: Lunaris Codex CI

on:
  push:
    branches: [ main ]
    paths:
      - 'model.py'
      - 'prepare_data.py'
      - 'train.py'
      - 'inference.py'
      - 'text_cleaner/**'
      - 'data_analyzer/**'
      - 'bpe_trainer/**'
      - 'tests/**'
      - 'Makefile'
      - 'requirements.txt'
      - '.github/workflows/ci.yml'
      - 'third_party/**'
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches: [ main ]
  workflow_dispatch:

env:
  CXXFLAGS_MODE: RELEASE
  PYTHON_VERSION: '3.11'
  # Tentar for√ßar Python a usar UTF-8, especialmente √∫til no Windows
  PYTHONUTF8: "1" 
  # Para Rich no Windows, pode ajudar
  FORCE_COLOR: "1" # Ou "true"
  TERM: "xterm-256color" # Define um TERM que Rich entende como com suporte a cores

jobs:
  detect_changes:
    name: Detect Changes & Setup Matrix
    runs-on: ubuntu-latest
    outputs:
      # ... (igual ao anterior)
      cpp_changes: ${{ steps.cpp_changes.outputs.any_changed }}
      python_changes: ${{ steps.python_changes.outputs.any_changed }}
      should_run_cpp: ${{ steps.decision.outputs.should_run_cpp }}
      should_run_python: ${{ steps.decision.outputs.should_run_python }}
      test_matrix: ${{ steps.matrix.outputs.matrix }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      # ... (detect changes e decision igual ao anterior)
      - name: Detect C++ Changes
        id: cpp_changes
        uses: tj-actions/changed-files@v46
        with:
          files: |
            Makefile
            text_cleaner/**
            data_analyzer/**
            bpe_trainer/**
            third_party/**
            .github/workflows/ci.yml

      - name: Detect Python Changes
        id: python_changes
        uses: tj-actions/changed-files@v46
        with:
          files: |
            model.py
            prepare_data.py
            train.py
            inference.py
            tests/**
            requirements.txt
            .github/workflows/ci.yml

      - name: Determine Job Execution
        id: decision
        run: |
          if [[ "${{ steps.cpp_changes.outputs.any_changed }}" == "true" || \
                "${{ github.event_name }}" == "push" || \
                "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_run_cpp=true" >> $GITHUB_OUTPUT
          else
            echo "should_run_cpp=false" >> $GITHUB_OUTPUT
          fi
          if [[ "${{ steps.python_changes.outputs.any_changed }}" == "true" || \
                "${{ github.event_name }}" == "push" || \
                "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_run_python=true" >> $GITHUB_OUTPUT
          else
            echo "should_run_python=false" >> $GITHUB_OUTPUT
          fi
      - name: Setup Test Matrix
        id: matrix
        run: |
          cat <<EOF > matrix.json
          {
            "os": [
              { "name": "ubuntu-latest", "display": "Ubuntu Latest", "runner": "ubuntu-latest", "os_type_make": "Linux" },
              { "name": "ubuntu-22.04", "display": "Ubuntu 22.04", "runner": "ubuntu-22.04", "os_type_make": "Linux" },
              { "name": "windows-latest", "display": "Windows Latest", "runner": "windows-latest", "os_type_make": "Windows_NT" },
              { "name": "macos-latest", "display": "macOS Latest", "runner": "macos-latest", "os_type_make": "Darwin" }
            ]
          }
          EOF
          echo "matrix=$(cat matrix.json | jq -c .)" >> $GITHUB_OUTPUT

  cpp_utilities:
    name: C++ Build & Test (${{ matrix.os.display }})
    runs-on: ${{ matrix.os.runner }}
    needs: detect_changes
    if: needs.detect_changes.outputs.should_run_cpp == 'true'
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect_changes.outputs.test_matrix) }}
    defaults:
      run:
        shell: bash
    outputs:
      # ... (igual ao anterior)
      text_cleaner_exec: ${{ steps.executables.outputs.text_cleaner_exec }}
      data_analyzer_exec: ${{ steps.executables.outputs.data_analyzer_exec }}
      bpe_processor_exec: ${{ steps.executables.outputs.bpe_processor_exec }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Build Dependencies
        run: |
          echo "üîß Installing C++ build dependencies on ${{ matrix.os.display }} (runner.os: ${{ runner.os }})..."
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            sudo apt-get update -y
            sudo apt-get install -y nlohmann-json3-dev build-essential
          elif [[ "${{ runner.os }}" == "Windows" ]];
          then # Adicionando uma verifica√ß√£o mais robusta para MinGW no PATH
            choco install mingw --no-progress --yes
            echo "C:/ProgramData/chocolatey/lib/mingw/tools/install/mingw64/bin" >> $GITHUB_PATH
            echo "Verifying MinGW Path:"
            where g++ || echo "g++ not found with 'where', checking common paths"
            if [ -f "C:/ProgramData/chocolatey/lib/mingw/tools/install/mingw64/bin/g++.exe" ]; then
                echo "MinGW g++ found at choco default path."
            elif [ -f "C:/MinGW/bin/g++.exe" ]; then
                echo "MinGW g++ found at C:/MinGW/bin"
                echo "C:/MinGW/bin" >> $GITHUB_PATH
            else
                echo "WARNING: MinGW g++ not found in common paths."
            fi
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            brew install nlohmann-json
          fi
          echo "Verifying g++:"
          g++ --version || echo "g++ not found or not in PATH"


      # ... (Cache, Clean, List files igual ao anterior)
      - name: Cache C++ Executables
        id: cache_executables
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/text_cleaner/lunaris_text_cleaner*
            ${{ github.workspace }}/data_analyzer/lunaris_data_analyzer*
            ${{ github.workspace }}/bpe_trainer/bpe_processor*
          key: ${{ matrix.os.runner }}-${{ matrix.os.os_type_make }}-cpp-exec-${{ hashFiles('Makefile', 'text_cleaner/**/*.cpp', 'data_analyzer/**/*.cpp', 'bpe_trainer/**/*.cpp', 'third_party/**/*.hpp') }}
          restore-keys: |
            ${{ matrix.os.runner }}-${{ matrix.os.os_type_make }}-cpp-exec-

      - name: Clean Previous Build Artifacts
        run: |
          make clean OS_TYPE=${{ matrix.os.os_type_make }} || echo "‚ÑπÔ∏è No previous artifacts or clean failed."

      - name: List files before build (DEBUG)
        run: |
          ls -lA
          ls -lA text_cleaner/ || true
          ls -lA data_analyzer/ || true
          ls -lA bpe_trainer/ || true
          ls -lA third_party/nlohmann/ || true

      - name: Build C++ Utilities
        if: steps.cache_executables.outputs.cache-hit != 'true'
        run: |
          make all CXXFLAGS_MODE=${{ env.CXXFLAGS_MODE }} OS_TYPE=${{ matrix.os.os_type_make }}
          echo "‚úÖ C++ utilities built successfully"

      - name: Set Executable Paths
        id: executables
        run: |
          # ... (igual ao anterior, com logs de verifica√ß√£o)
          EXE_SUFFIX=""
          if [[ "${{ matrix.os.os_type_make }}" == "Windows_NT" ]]; then
            EXE_SUFFIX=".exe"
          fi
          echo "text_cleaner_exec=${{ github.workspace }}/text_cleaner/lunaris_text_cleaner$EXE_SUFFIX" >> $GITHUB_OUTPUT
          echo "data_analyzer_exec=${{ github.workspace }}/data_analyzer/lunaris_data_analyzer$EXE_SUFFIX" >> $GITHUB_OUTPUT
          echo "bpe_processor_exec=${{ github.workspace }}/bpe_trainer/bpe_processor$EXE_SUFFIX" >> $GITHUB_OUTPUT
          if [[ "${{ steps.cache_executables.outputs.cache-hit }}" == "true" ]]; then
            echo "‚ôªÔ∏è C++ executables restored from cache"
          else
            echo "üÜï C++ executables built from source"
          fi
          echo "Verificando execut√°veis criados/em cache:"
          ls -l "${{ github.workspace }}/text_cleaner/lunaris_text_cleaner${EXE_SUFFIX}" || echo "Text cleaner exec not found"
          ls -l "${{ github.workspace }}/data_analyzer/lunaris_data_analyzer${EXE_SUFFIX}" || echo "Data analyzer exec not found"
          ls -l "${{ github.workspace }}/bpe_trainer/bpe_processor${EXE_SUFFIX}" || echo "BPE processor exec not found"

      - name: Run Text Cleaner Tests
        run: |
          echo "üß™ Testing Text Cleaner utility on ${{ matrix.os.display }}..."
          TEXT_CLEANER_EXEC_PATH="${{ steps.executables.outputs.text_cleaner_exec }}"
          echo "Current directory: $(pwd)"
          echo "Attempting to execute: $TEXT_CLEANER_EXEC_PATH"
          ls -lA "$TEXT_CLEANER_EXEC_PATH" || echo "Executable not found at path"

          # Modifica√ß√£o para Windows
          if [[ "${{ matrix.os.os_type_make }}" == "Windows_NT" ]]; then
            # Tentar executar diretamente ou via cmd /c
            "$TEXT_CLEANER_EXEC_PATH" \
              --input ./temp_text_cleaner_input/sample.txt \
              --output ./temp_text_cleaner_output/cleaned.txt \
              --remove-html --normalize-whitespace --remove-empty-lines \
              --to-lowercase \
              --process-urls --url-placeholder "[url]" \
              --process-emails --email-placeholder "[email]" \
              --remove-exact-duplicates || \
            cmd /c "$TEXT_CLEANER_EXEC_PATH" \
              --input ./temp_text_cleaner_input/sample.txt \
              --output ./temp_text_cleaner_output/cleaned.txt \
              --remove-html --normalize-whitespace --remove-empty-lines \
              --to-lowercase \
              --process-urls --url-placeholder "[url]" \
              --process-emails --email-placeholder "[email]" \
              --remove-exact-duplicates
          else
            "$TEXT_CLEANER_EXEC_PATH" \
              --input ./temp_text_cleaner_input/sample.txt \
              --output ./temp_text_cleaner_output/cleaned.txt \
              --remove-html --normalize-whitespace --remove-empty-lines \
              --to-lowercase \
              --process-urls --url-placeholder "[url]" \
              --process-emails --email-placeholder "[email]" \
              --remove-exact-duplicates
          fi

          mkdir -p ./temp_text_cleaner_input ./temp_text_cleaner_output # Mover para antes da execu√ß√£o
          cat <<EOF > ./temp_text_cleaner_input/sample.txt
          <!DOCTYPE html>
          <html> <head><title>Test</title></head> <body>
          <!-- This is a comment -->
          <p>Hello   World!  </p>
          <script>alert("script content");</script>
          Another line.
          URL: http://example.com and email: test@example.com
          Duplicate Line
          Duplicate Line
          </body> </html>
          EOF
          
          # (Execu√ß√£o do Text Cleaner movida para cima)

          cat <<-EXPECTED_EOF > expected_output.txt
          test
          hello world!
          another line.
          url: [url] and email: [email]
          duplicate line
          EXPECTED_EOF
          if diff -u expected_output.txt ./temp_text_cleaner_output/cleaned.txt; then
            echo "‚úÖ Text Cleaner test passed on ${{ matrix.os.display }}"
          else
            echo "‚ùå Text Cleaner test failed on ${{ matrix.os.display }}"
            # Mostrar o conte√∫do dos arquivos para depura√ß√£o
            echo "--- Expected Output ---"
            cat expected_output.txt
            echo "--- Actual Output ---"
            cat ./temp_text_cleaner_output/cleaned.txt
            echo "-----------------------"
            exit 1
          fi

      - name: Run BPE Processor Tests
        run: |
          # ... (igual ao anterior, mas com verifica√ß√£o similar para Windows se necess√°rio)
          echo "üß™ Testing BPE Processor on ${{ matrix.os.display }}..."
          BPE_EXEC_PATH="${{ steps.executables.outputs.bpe_processor_exec }}"
          if [ ! -f "$BPE_EXEC_PATH" ]; then
            echo "‚ùå ERROR: BPE Processor executable not found at: $BPE_EXEC_PATH"
            ls -lA "${{ github.workspace }}/bpe_trainer/"
            exit 1
          fi
          
          mkdir -p ./temp_bpe/corpus ./temp_bpe/model_output
          cat <<EOF > ./temp_bpe/corpus/corpus.txt
          hello world this is a test a test
          another line for another test of the bpe
          hello world again
          EOF

          # Modifica√ß√£o para Windows
          if [[ "${{ matrix.os.os_type_make }}" == "Windows_NT" ]]; then
             "$BPE_EXEC_PATH" \
              --action train \
              --corpus ./temp_bpe/corpus/corpus.txt \
              --vocab-size 270 \
              --output ./temp_bpe/model_output/bpe_model/ \
              --mode byte --verbose || \
            cmd /c "$BPE_EXEC_PATH" \
              --action train \
              --corpus ./temp_bpe/corpus/corpus.txt \
              --vocab-size 270 \
              --output ./temp_bpe/model_output/bpe_model/ \
              --mode byte --verbose
          else
            "$BPE_EXEC_PATH" \
              --action train \
              --corpus ./temp_bpe/corpus/corpus.txt \
              --vocab-size 270 \
              --output ./temp_bpe/model_output/bpe_model/ \
              --mode byte --verbose
          fi

          REQUIRED_FILES=(
            "./temp_bpe/model_output/bpe_model/bpe_model_lunaris.json"
            "./temp_bpe/model_output/bpe_model/merges_lunaris.txt"
            "./temp_bpe/model_output/bpe_model/vocabulary_lunaris.txt"
          )
          for file in "${REQUIRED_FILES[@]}"; do
            if [ ! -f "$file" ]; then
              echo "‚ùå ERROR: Required output file not found: $file"
              ls -R ./temp_bpe/model_output/
              exit 1
            fi
          done
          # A tokeniza√ß√£o tamb√©m pode precisar da chamada cmd /c no Windows
          TOKEN_OUTPUT=""
          if [[ "${{ matrix.os.os_type_make }}" == "Windows_NT" ]]; then
             TOKEN_OUTPUT=$( "$BPE_EXEC_PATH" --action tokenize --model_path "./temp_bpe/model_output/bpe_model/" --input_text "hello test world" --verbose || \
                             cmd /c "$BPE_EXEC_PATH" --action tokenize --model_path "./temp_bpe/model_output/bpe_model/" --input_text "hello test world" --verbose )
          else
             TOKEN_OUTPUT=$( "$BPE_EXEC_PATH" --action tokenize --model_path "./temp_bpe/model_output/bpe_model/" --input_text "hello test world" --verbose )
          fi

          if [ $? -ne 0 ] || [ -z "$TOKEN_OUTPUT" ]; then
            echo "‚ùå ERROR: BPE tokenization failed. Output: $TOKEN_OUTPUT"
            exit 1
          fi
          echo "‚úÖ BPE Processor test passed on ${{ matrix.os.display }}"


      - name: Cleanup Test Files
        if: always()
        run: |
          rm -rf ./temp_text_cleaner_input ./temp_text_cleaner_output ./expected_output.txt ./temp_bpe

  python_suite:
    name: Python Tests (${{ matrix.os.display }})
    runs-on: ${{ matrix.os.runner }}
    needs: detect_changes
    if: needs.detect_changes.outputs.should_run_python == 'true'
    env: # Definir env vars aqui para todos os steps do job python_suite
      PYTHONUTF8: "1"
      FORCE_COLOR: "1"
      TERM: "xterm-256color"
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect_changes.outputs.test_matrix) }}
    defaults:
      run:
        shell: bash

    steps:
      # ... (Checkout, Setup Python, Cache, Install Dependencies igual ao anterior)
      - name: Checkout Repository
        uses: actions/checkout@v4
      - name: Setup Python Environment
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Display Python Info
        run: |
          python --version
          pip --version
      - name: Cache Python Dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ matrix.os.runner }}-${{ matrix.os.os_type_make }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ matrix.os.runner }}-${{ matrix.os.os_type_make }}-pip-
      - name: Install Python Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: List files for Python tests (DEBUG)
        run: |
          ls -lA
          ls -lA model.py || true
          ls -lA tests/test_model.py || true

      - name: Run Unit Tests
        run: |
          # ... (igual ao anterior)
          python -m pytest tests/ -k "test_model" \
            --cov=model \
            --cov-report=xml:coverage-${{ matrix.os.name }}.xml \
            --cov-report=term-missing \
            --tb=short
          echo "‚úÖ Unit tests completed on ${{ matrix.os.display }}"

      - name: Upload Coverage Report
        if: success() && matrix.os.os_type_make == 'Linux'
        uses: codecov/codecov-action@v4
        # ... (igual ao anterior)
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage-${{ matrix.os.name }}.xml
          flags: model-tests-${{ matrix.os.name }}
          name: codecov-${{ matrix.os.name }}
          fail_ci_if_error: true
          
      # --- Integration Tests ---
      # As vari√°veis de ambiente PYTHONUTF8, FORCE_COLOR, TERM definidas no n√≠vel do job devem ser herdadas aqui.
      - name: Create Test Datasets
        run: |
          # ... (igual ao anterior)
          mkdir -p ./temp_train_data ./temp_val_data
          echo "def train_function_one(): return 'train1'" > ./temp_train_data/train_sample_1.py
          echo "class TrainSampleClass:\n  value = 'train2'" > ./temp_train_data/train_sample_2.py
          echo "def validation_function(): return 'validation_data_here'" > ./temp_val_data/val_sample_1.py
          echo "# Another validation line" > ./temp_val_data/val_sample_2.py

      - name: Test Data Preparation
        env:
          HF_TOKEN: ${{ secrets.HF_TOKEN }}
        run: |
          # ... (igual ao anterior)
          python prepare_data.py \
            --data_source_type text_file_lines \
            --dataset_name_or_path "./temp_train_data/*.py" \
            --tokenizer_name_or_path gpt2 \
            --output_path ./processed_data/train_data.memmap \
            --max_length 32 --max_examples 2 --overwrite_output
          python prepare_data.py \
            --data_source_type text_file_lines \
            --dataset_name_or_path "./temp_val_data/*.py" \
            --tokenizer_name_or_path gpt2 \
            --output_path ./processed_data/val_data.memmap \
            --max_length 32 --max_examples 2 --overwrite_output

      - name: Test Training Pipeline
        env:
          HF_TOKEN: ${{ secrets.HF_TOKEN }}
        run: |
          # ... (igual ao anterior)
          python train.py \
            --memmap_file_train ./processed_data/train_data.memmap \
            --num_sequences_train 2 \
            --memmap_file_val ./processed_data/val_data.memmap \
            --num_sequences_val 2 \
            --tokenizer_name_or_path gpt2 \
            --dataset_max_length 32 --dataset_dtype int32 \
            --model_max_seq_len 32 --d_model 32 --n_layers 1 --n_heads 1 \
            --batch_size 1 --num_epochs 1 --device cpu \
            --checkpoint_dir ./checkpoints \
            --log_interval 1 --save_strategy epoch \
            --lora_rank 0 --seed 42

      - name: Test Inference Pipeline
        run: |
          # ... (igual ao anterior)
          # As env vars PYTHONUTF8, etc., devem ajudar aqui.
          CHECKPOINT_PATH="./checkpoints/best_model.pt"
          if [ ! -f "$CHECKPOINT_PATH" ]; then
            ls -la ./checkpoints/
            exit 1
          fi
          # O ideal seria o script inference.py lidar com a detec√ß√£o de console legado
          # mas PYTHONUTF8=1 pode ser suficiente.
          OUTPUT=$(python inference.py \
            --checkpoint_path "$CHECKPOINT_PATH" \
            --tokenizer_name_or_path gpt2 \
            --prompt "Test prompt:" \
            --max_new_tokens 5 \
            --temperature 0.5 \
            --device cpu --no_color) # --no_color j√° desabilita cores de rich
          if [ $? -eq 0 ] && [ -n "$OUTPUT" ]; then
            echo "Generated output (first 100 chars): ${OUTPUT:0:100}..."
          else
            exit 1
          fi


      - name: Cleanup Test Files
        if: always()
        run: |
          rm -rf ./temp_train_data ./temp_val_data ./processed_data ./checkpoints ./coverage-${{ matrix.os.name }}.xml

  ci_status:
    # ... (igual ao anterior)
    name: CI Status Report
    runs-on: ubuntu-latest
    needs: [detect_changes, cpp_utilities, python_suite]
    if: always()
    steps:
      - name: Determine Overall Status
        id: status
        shell: bash
        run: |
          CPP_JOB_EXISTS="${{ needs.detect_changes.outputs.should_run_cpp }}"
          PYTHON_JOB_EXISTS="${{ needs.detect_changes.outputs.should_run_python }}"
          CPP_STATUS="skipped" 
          if [[ "$CPP_JOB_EXISTS" == "true" ]]; then
            CPP_STATUS="${{ needs.cpp_utilities.result || 'failure' }}" 
          fi
          PYTHON_STATUS="skipped"
          if [[ "$PYTHON_JOB_EXISTS" == "true" ]]; then
            PYTHON_STATUS="${{ needs.python_suite.result || 'failure' }}"
          fi
          echo "üîç Job Status Summary:"
          echo "  - C++ Jobs (Should Run: $CPP_JOB_EXISTS): $CPP_STATUS"
          echo "  - Python Jobs (Should Run: $PYTHON_JOB_EXISTS): $PYTHON_STATUS"
          OVERALL_SUCCESS="true"
          if [[ "$CPP_JOB_EXISTS" == "true" && "$CPP_STATUS" != "success" && "$CPP_STATUS" != "skipped" ]]; then
            OVERALL_SUCCESS="false"
          fi
          if [[ "$PYTHON_JOB_EXISTS" == "true" && "$PYTHON_STATUS" != "success" && "$PYTHON_STATUS" != "skipped" ]]; then
            OVERALL_SUCCESS="false"
          fi
          if [[ "$CPP_JOB_EXISTS" == "false" && "$PYTHON_JOB_EXISTS" == "false" ]]; then
            OVERALL_SUCCESS="true" 
          fi
          echo "overall_success=$OVERALL_SUCCESS" >> "$GITHUB_OUTPUT"
          if [[ "$OVERALL_SUCCESS" == "true" ]]; then
            echo "‚úÖ Overall CI Status: SUCCESS"
          else
            echo "‚ùå Overall CI Status: FAILURE"
          fi
      - name: Post Comment (PR)
        if: github.event_name == 'pull_request'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
        run: |
          STATUS_ICON="‚úÖ"
          STATUS_TEXT="SUCCESS"
          if [[ "${{ steps.status.outputs.overall_success }}" == "false" ]]; then
            STATUS_ICON="‚ùå"
            STATUS_TEXT="FAILED"
          fi
          COMMENT_BODY="---
          **Lunaris Codex CI Status: $STATUS_TEXT $STATUS_ICON** 
          Workflow: \`${{ github.workflow }}\`
          Branch: \`${{ github.head_ref }}\` (Commit: \`${{ github.sha }}\`)
          üîó [View Action Details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          *This is an automated message.*"
          gh pr comment ${{ github.event.pull_request.number }} --body "$COMMENT_BODY" || echo "‚ö†Ô∏è Failed to post comment"
      - name: Final Status Check
        shell: bash
        run: |
          if [[ "${{ steps.status.outputs.overall_success }}" == "false" ]]; then
            echo "‚ùå CI Pipeline failed - exiting with error code"
            exit 1
          else
            echo "‚úÖ CI Pipeline completed successfully"
          fi
