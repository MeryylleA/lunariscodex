# .github/workflows/ci.yml
name: Lunaris Codex CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  lint-and-test: # Renomeado para incluir linting
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Cache Python dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install Python dependencies and flake8
        run: |
          python -m venv .venv-ci
          source .venv-ci/bin/activate
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install flake8 # Instalar flake8

      - name: Lint with flake8
        run: |
          source .venv-ci/bin/activate
          # Stop the build if there are Python syntax errors or undefined names
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          # Exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
      
      - name: Create dummy datasets for CI
        run: |
          mkdir -p ./temp_data_ci_train
          echo "def train_function_one(): return 'train1'" > ./temp_data_ci_train/train_sample_1.py
          echo "class TrainSampleClass:\n  value = 'train2'" > ./temp_data_ci_train/train_sample_2.py
          mkdir -p ./temp_data_ci_val
          echo "def validation_function(): return 'validation_data_here'" > ./temp_data_ci_val/val_sample_1.py
          echo "# Another validation line" > ./temp_data_ci_val/val_sample_2.py

      - name: Run prepare_data.py for CI datasets
        env:
          HF_TOKEN: ${{ secrets.HF_TOKEN }}
        run: |
          source .venv-ci/bin/activate
          echo "--- Preparing Training Data for CI ---"
          python prepare_data.py \
            --data_source_type text_file_lines \
            --dataset_name_or_path "./temp_data_ci_train/*.py" \
            --tokenizer_name_or_path gpt2 \
            --max_length 32 \
            --output_path ./processed_data_ci/ci_train_data.memmap \
            --max_examples 2

          echo "--- Preparing Validation Data for CI ---"
          python prepare_data.py \
            --data_source_type text_file_lines \
            --dataset_name_or_path "./temp_data_ci_val/*.py" \
            --tokenizer_name_or_path gpt2 \
            --max_length 32 \
            --output_path ./processed_data_ci/ci_val_data.memmap \
            --max_examples 2

      - name: Cache C++ build (Data Analyzer)
        id: cache-data-analyzer
        uses: actions/cache@v3
        with:
          path: data_analyzer/lunaris_data_analyzer # Cache o executável com o nome definido no Makefile
          key: ${{ runner.os }}-data-analyzer-${{ hashFiles('data_analyzer/Makefile', 'data_analyzer/lunaris_data_analyzer.cpp') }}
          restore-keys: |
            ${{ runner.os }}-data-analyzer-

      - name: Build C++ data analyzer (using Makefile)
        # Este step agora roda condicionalmente se o cache não for encontrado
        # OU se você quiser sempre reconstruir para pegar mudanças no Makefile não refletidas no hash do .cpp
        # Para forçar a reconstrução se o Makefile mudar, a chave do cache já inclui 'data_analyzer/Makefile'.
        # Se o executável não existir após a tentativa de restaurar do cache, construa.
        # O 'if' abaixo é mais explícito para o caso de o cache falhar em criar o arquivo.
        if: steps.cache-data-analyzer.outputs.cache-hit != 'true' || !isfile('data_analyzer/lunaris_data_analyzer')
        working-directory: ./data_analyzer
        run: |
          echo "Building lunaris_data_analyzer..."
          make || { echo "C++ compilation failed"; exit 1; }
          
      - name: Test C++ data analyzer
        run: |
          echo "Executing data analyzer..."
          # Ajuste o caminho para o executável, se necessário, baseado no TARGET do Makefile
          ./data_analyzer/lunaris_data_analyzer \
            --file ./processed_data_ci/ci_train_data.memmap \
            --num_sequences 2 \
            --max_length 32 \
            --dtype int32 \
            --print_seq 1 \
            --top_n_tokens 3 || { echo "Analyzer execution failed"; exit 1; }

      - name: Run train.py (toy model with validation)
        env:
          HF_TOKEN: ${{ secrets.HF_TOKEN }}
        run: |
          source .venv-ci/bin/activate
          python train.py \
            --memmap_file_train ./processed_data_ci/ci_train_data.memmap \
            --num_sequences_train 2 \
            --memmap_file_val ./processed_data_ci/ci_val_data.memmap \
            --num_sequences_val 2 \
            --tokenizer_name_or_path gpt2 \
            --dataset_max_length 32 \
            --dataset_dtype int32 \
            --model_max_seq_len 32 \
            --d_model 32 \
            --n_layers 1 \
            --n_heads 1 \
            --batch_size 1 \
            --num_epochs 1 \
            --device cpu \
            --checkpoint_dir ./checkpoints_ci \
            --log_interval 1 \
            --save_strategy epoch \
            --lora_rank 0 \
            --seed 42

      - name: Check for checkpoint files
        run: |
          echo "Listing contents of checkpoint directory: ./checkpoints_ci"
          ls -R ./checkpoints_ci
          
          MAIN_CKPT_FILE="./checkpoints_ci/lunaris_codex_epoch-1_step-2.pt"
          BEST_MODEL_FILE="./checkpoints_ci/best_model.pt"

          if [ ! -f "$MAIN_CKPT_FILE" ]; then
            echo "ERROR: Main checkpoint file '$MAIN_CKPT_FILE' not found!"
            exit 1
          fi
          if [ ! -f "$BEST_MODEL_FILE" ]; then
            echo "ERROR: 'best_model.pt' not found!"
            exit 1
          fi
          echo "All expected checkpoint files found."

      - name: Clean up
        if: always()
        run: |
          rm -rf .venv-ci ./temp_data_ci_train ./temp_data_ci_val ./processed_data_ci ./checkpoints_ci
          # Use o make clean para limpar os artefatos de build C++
          if [ -f "data_analyzer/Makefile" ]; then
            (cd data_analyzer && make clean)
          else
            rm -f data_analyzer/lunaris_data_analyzer data_analyzer/*.o
          fi
          echo "Cleaned up temporary files and directories."
